# -*- coding: utf-8 -*-
"""Trabalho1_Calculo2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QA4EXLYlB4BXCXsxas-ko7j4D830IFuy
"""

import numpy as np
import matplotlib.pyplot as plt

# Definir os parâmetros para o gráfico
anos = np.arange(0, 9, 1)
alimento = 20 + 20 * anos               # Crescimento linear do alimento começando em 20
populacao = 20 * np.exp(0.3 * anos)     # Crescimento exponencial da população começando em 20

# Encontrar o ponto de crise (onde a população ultrapassa o alimento)
ponto_crise = np.where(populacao > alimento)[0][0]
ano_crise = anos[ponto_crise]
populacao_crise = populacao[ponto_crise]

# Criar o gráfico
plt.plot(anos, populacao, label='população', color='#C8A2C8', linewidth=2)  # Cor lilás para a população
plt.plot(anos, alimento, label='alimentos', color='purple', linewidth=2)

# Adicionar o ponto de crise ao gráfico
plt.scatter(ano_crise-0.16, populacao_crise-5, color='black', zorder=5)  # Adiciona um ponto preto e ajusta a ordem de sobreposição
plt.text(ano_crise - 1.7, populacao_crise + 4, 'ponto de crise', fontsize=10, rotation=0)  # Adiciona o texto próximo ao ponto e o deixa reto

# Adicionar legendas e rótulos
plt.xlabel('Tempo', fontsize=12)
plt.ylabel('Quantidade', fontsize=12)
plt.legend()
plt.title('Teoria de Malthus', fontsize=14)

# Ajustar os limites do gráfico
plt.xlim(0, 8)
plt.ylim(0, max(populacao) +10)

# Mostrar o gráfico
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definir os valores de t
t = np.linspace(0, 10, 500)

# Definir as funções para cada gráfico
N_a = np.full_like(t, 1)
N_b = np.exp(t/2)
N_c = 2 / t

# Recriar os gráficos sem grid e começando no eixo y
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico (a)
axs[0].plot(t, N_a, color='purple')
axs[0].set_title('(a)')
axs[0].set_xlabel('t')
axs[0].set_ylabel('N(t)')
axs[0].set_ylim(0, 2)
axs[0].set_xlim(0, 10)
axs[0].set_xticks([])
axs[0].set_yticks([])
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)
axs[0].spines['bottom'].set_position('zero')
axs[0].spines['left'].set_position('zero')

# Gráfico (b)
axs[1].plot(t, N_b, color='purple')
axs[1].set_title('(b)')
axs[1].set_xlabel('t')
axs[1].set_ylim(0, np.max(N_b))
axs[1].set_xlim(0, 10)
axs[1].set_xticks([])
axs[1].set_yticks([])
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].spines['bottom'].set_position('zero')
axs[1].spines['left'].set_position('zero')

# Gráfico (c)
axs[2].plot(t, N_c, color='purple')
axs[2].set_title('(c)')
axs[2].set_xlabel('t')
axs[2].set_ylim(0, 2)
axs[2].set_xlim(0, 10)
axs[2].set_xticks([])
axs[2].set_yticks([])
axs[2].spines['top'].set_visible(False)
axs[2].spines['right'].set_visible(False)
axs[2].spines['bottom'].set_position('zero')
axs[2].spines['left'].set_position('zero')

plt.tight_layout()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definir os valores de t
t = np.linspace(0.1, 10, 500)  # Começa de 0.1 para evitar divisão por zero

# Definir as funções para cada gráfico
N_a = np.full_like(t, 1)
N_b = np.exp(t / 2)
N_c = 2 / t

# Recriar os gráficos
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico (a)
axs[0].plot(t, N_a, color='purple')
axs[0].set_title('(a)')
axs[0].set_xlabel('t')
axs[0].set_ylabel('N(t)')
axs[0].set_ylim(0, 2)
axs[0].grid(True)

# Gráfico (b)
axs[1].plot(t, N_b, color='purple')
axs[1].set_title('(b)')
axs[1].set_xlabel('t')
axs[1].set_ylim(0, np.max(N_b))
axs[1].grid(True)

# Gráfico (c)
axs[2].plot(t, N_c, color='purple')
axs[2].set_title('(c)')
axs[2].set_xlabel('t')
axs[2].set_ylim(0, 2)
axs[2].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parâmetros do modelo logístico
K = 300  # Capacidade de carga
P0 = 10  # População inicial
r = 1  # Aumentando a taxa de crescimento para ajustar o gráfico

# Função do modelo logístico
def logistic_growth(t, P0, r, K):
    return K / (1 + (K / P0 - 1) * np.exp(-r * t))

# Intervalo de tempo
t = np.linspace(0, 15, 300)

# Cálculo da população ao longo do tempo
P = logistic_growth(t, P0, r, K)

# Plot do gráfico
plt.figure(figsize=(8, 5))
plt.plot(t, P, color='purple', linewidth=2)

# Configurações do gráfico
plt.xlabel('Tempo', fontsize=14)
plt.ylabel('População', fontsize=14)
plt.title('Crescimento Populacional', fontsize=16)

# Ajuste da escala do eixo y
plt.ylim(0, K + 50)

plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definindo os parâmetros
P_infinity = 1  # Valor de P∞
t = np.linspace(0, 1, 500)  # Intervalo de tempo
P = P_infinity * (1 - (2 * (t - 0.5))**2)  # Função parabólica representando o gráfico

# Criando o gráfico
plt.figure(figsize=(6,6))
plt.plot(t, P, color='purple')

# Adicionando os pontos e anotações
plt.axvline(0.5, color='purple', linestyle='--')  # Linha vertical no ponto médio
plt.scatter(0.5, P_infinity, color='purple')  # Ponto no máximo

# Adicionando as anotações
plt.text(0.5, P_infinity + 0.03, 'variação máxima', ha='center', va='bottom')
plt.text(0.5, -0.1, '$t_m$', ha='center', va='top')
plt.text(1.02, 0, '$P_{\infty}$', ha='left', va='center')
plt.text(-0.02, 0, '$0$', ha='right', va='center')

# Ajustando os limites e o layout
plt.ylim(0, 1.1 * P_infinity)
plt.xlim(0, 1)
plt.yticks([0, P_infinity/2, P_infinity], ['$0$', r'$\frac{P_{\infty}}{2}$', r'$P_{\infty}$'])
plt.xticks([0, 0.5, 1], ['$0$', r'$t_m$', r'$P_{\infty}$'])

# Ativando o grid em todo o gráfico
plt.grid(True)

# Removendo as bordas superiores e direitas
plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)

# Exibindo o gráfico
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para modelar o comportamento da curva com base na taxa de crescimento r
def growth_model(t, N0, r):
    return N0 * np.exp(r * t)

# Definindo os parâmetros
t = np.linspace(0, 10, 400)
N0 = 1
r_values = [0.5, 0, -0.5]  # r > 0, r = 0, r < 0

# Criando os gráficos
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico 1: r > 0
axs[0].plot(t, growth_model(t, N0, r_values[0]), color='purple')
axs[0].set_title('r > 0 (Crescimento)')
axs[0].grid(True)  # Adicionando grade
axs[0].set_ylim(0, 5)  # Ajustando o limite do eixo y para melhorar a visualização

# Gráfico 2: r = 0
axs[1].plot(t, growth_model(t, N0, r_values[1]), color='purple')
axs[1].set_title('r = 0 (Constante)')
axs[1].grid(True)  # Adicionando grade

# Gráfico 3: r < 0
axs[2].plot(t, growth_model(t, N0, r_values[2]), color='purple')
axs[2].set_title('r < 0 (Decaimento)')
axs[2].grid(True)  # Adicionando grade

# Configurações finais
for ax in axs:
    ax.set_xlabel('t')
    ax.set_ylabel('N(t)')
    ax.set_xlim(0, 10)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função logística que modela o crescimento populacional com estabilização em k
def logistic_model(t, N0, r, k):
    return k / (1 + (k/N0 - 1) * np.exp(-r * t))

# Definindo os parâmetros
t = np.linspace(0, 20, 400)  # Aumentando o intervalo de tempo
N0 = 0.1  # População inicial
k = 1  # Capacidade máxima do ambiente
r_values = [1.5, 0, -0.5]  # r > 0, r = 0, r < 0

# Criando os gráficos
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico 1: r > 0 (crescimento com estabilização em k)
axs[0].plot(t, logistic_model(t, N0, r_values[0], k), color='purple')
axs[0].set_title('r > 0 (Crescimento)')
axs[0].grid(True)

# Gráfico 2: r = 0 (população constante)
axs[1].plot(t, logistic_model(t, N0, r_values[1], k), color='purple')
axs[1].set_title('r = 0 (Constante)')
axs[1].grid(True)

# Gráfico 3: r < 0 (decaimento populacional)
axs[2].plot(t, logistic_model(t, N0, r_values[2], k), color='purple')
axs[2].set_title('r < 0 (Decaimento)')
axs[2].grid(True)
axs[2].set_ylim(0, k + 0.2)  # Ajuste do limite superior do eixo y para maior visibilidade

# Configurações finais
for ax in axs:
    ax.set_xlabel('t')
    ax.set_ylabel('N(t)')
    ax.set_xlim(0, 20)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função logística que modela o crescimento populacional com estabilização em k
def logistic_model(t, N0, r, k):
    return k / (1 + (k/N0 - 1) * np.exp(-r * t))

# Definindo os parâmetros
t = np.linspace(0, 20, 400)  # Aumentando o intervalo de tempo
N0 = 0.1  # População inicial
k = 1  # Capacidade máxima do ambiente
r_values = [0.5, 0, -0.4]  # r > 0, r = 0, r < 0

# Criando os gráficos
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico 1: r > 0 (crescimento com estabilização em k)
axs[0].plot(t, logistic_model(t, N0, r_values[0], k), color='purple')
axs[0].grid(True)
axs[0].set_ylim(0, 2.2)

# Gráfico 2: r = 0 (população constante)
axs[1].plot(t, logistic_model(t, N0, r_values[1], k), color='purple')
axs[1].grid(True)

# Gráfico 3: r < 0 (decaimento populacional)
axs[2].plot(t, logistic_model(t, N0, r_values[2], k), color='purple')
axs[2].grid(True)
axs[2].set_ylim(-0.15, 0.12)  # Ajuste do limite superior do eixo y para maior visibilidade

# Configurações finais
for ax in axs:
    ax.set_xlim(0, 15)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função logística que modela o crescimento populacional com estabilização em k
def logistic_model(t, N0, r, k):
    return k / (1 + (k/N0 - 1) * np.exp(-r * t))

# Definindo os parâmetros
t = np.linspace(0, 20, 400)
N0 = 0.1
k = 1
r_values = [1.5, 0, -0.5]

# Criando os gráficos
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Gráfico 1: r > 0 (crescimento com estabilização em k)
axs[0].plot(t[:200], logistic_model(t[:200], N0, r_values[0], k), color='purple')
axs[0].set_title('r > 0 (Crescimento)')
axs[0].grid(True)
axs[0].set_xlim(0, 20)  # A linha terminará no meio do gráfico horizontalmente
axs[0].set_ylim(0, 1)

# Gráfico 2: r = 0 (população constante)
axs[1].plot(t, logistic_model(t, N0, r_values[1], k), color='purple')
axs[1].set_title('r = 0 (Constante)')
axs[1].grid(True)
axs[1].set_xlim(0, 20)
axs[1].set_ylim(0.099, 0.101)

# Gráfico 3: r < 0 (decaimento populacional)
axs[2].plot(t, logistic_model(t, N0, r_values[2], k), color='purple')
axs[2].set_title('r < 0 (Decaimento)')
axs[2].grid(True)
axs[2].set_xlim(0, 20)
axs[2].set_ylim(0, 0.2)

# Configurações finais
for ax in axs:
    ax.set_xlabel('t')
    ax.set_ylabel('N(t)')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definindo os valores de x (por exemplo, de -10 a 10)
x = np.linspace(-20, 20, 400)

# Definindo a função parabólica (por exemplo, y = x^2)
y = x**2

# Criando o gráfico
plt.plot(x, y, color='purple')  # Usando a cor roxa

# Adicionando títulos e rótulos aos eixos

# Exibindo a grade
plt.grid(True)

# Exibindo o gráfico
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definindo os valores de x (por exemplo, de -10 a 10)
x = np.linspace(-20, 20, 400)

# Definindo a função parabólica (por exemplo, y = x^2)
y = -x**2

# Criando o gráfico
plt.plot(x, y, color='purple')  # Usando a cor roxa

# Adicionando títulos e rótulos aos eixos

# Exibindo a grade
plt.grid(True)

# Exibindo o gráfico
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula de Verhulst com variação calculada
def verhulst_model(P0, P_inf, t, alpha):
    Pt = (P0 * P_inf) / ((P_inf - P0) * np.exp(-alpha * t) + P0)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P_inf = 2800  # Capacidade de suporte estimada
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha usando a fórmula derivada do modelo logístico
alpha = -np.log((P_inf - P2) / (P2 * (P_inf - P1) / P1)) / (t2 - t1)

# Intervalo de tempo para prever o futuro
t_future = np.linspace(0, 60, 500)

# Cálculo da população futura usando o modelo de Verhulst
P_future = verhulst_model(P0, P_inf, t_future, alpha)

# Plotar o gráfico da população ao longo do tempo
plt.figure(figsize=(10, 6))
plt.plot(t_future, P_future, color='purple', label="Previsão de P(t) ")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo de Verhulst")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula de Verhulst com variação calculada
def verhulst_model(P0, P_inf, t, alpha):
    Pt = (P0 * P_inf) / ((P_inf - P0) * np.exp(-alpha * t) + P0)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P_inf = 2800  # Capacidade de suporte estimada
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha usando a fórmula derivada do modelo logístico
alpha = -np.log((P_inf - P2) / (P2 * (P_inf - P1) / P1)) / (t2 - t1)

# Intervalo de tempo para prever o futuro
t_future = np.linspace(0, 60, 600)

# Cálculo da população futura usando o modelo de Verhulst
P_future = verhulst_model(P0, P_inf, t_future, alpha)

# Previsões para os anos correspondentes (10, 20, 30, 40, 50, e agora 60)
predicted_population = {year: verhulst_model(P0, P_inf, year, alpha) for year in list(population_data.keys()) + [60]}

predicted_population

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula de Malthus
def malthus_model(P0, t, alpha):
    Pt = P0 * np.exp(alpha * t)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha usando a fórmula derivada do modelo de Malthus
alpha = np.log(P2 / P1) / (t2 - t1)

# Intervalo de tempo para prever o futuro
t_future = np.linspace(0, 60, 500)

# Cálculo da população futura usando o modelo de Malthus
P_future = malthus_model(P0, t_future, alpha)

# Plotar o gráfico da população ao longo do tempo
plt.figure(figsize=(10, 6))
plt.plot(t_future, P_future, color='purple', label="Modelo de Malthus")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo de Malthus")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula de Malthus
def malthus_model(P0, t, alpha):
    Pt = P0 * np.exp(alpha * t)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha usando a fórmula derivada do modelo de Malthus
alpha = np.log(P2 / P1) / (t2 - t1)

# Tempos específicos para os quais queremos calcular a população
t_specific = [0, 10, 20, 30, 40, 50]

# Cálculo da população para os tempos específicos usando o modelo de Malthus
P_specific = [malthus_model(P0, t, alpha) for t in t_specific]

# Intervalo de tempo para prever o futuro (para o gráfico)
t_future = np.linspace(0, 50, 500)
P_future = malthus_model(P0, t_future, alpha)

# Plotar o gráfico da população ao longo do tempo
plt.figure(figsize=(10, 6))
plt.plot(t_future, P_future, color='purple', label="Previsão de P(t) - Modelo de Malthus")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo de Malthus")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula discreta de Malthus
def malthus_discrete_model(P0, t, alpha):
    Pt = P0 * np.exp(np.log(1 + alpha) * t)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha para o modelo de Malthus discreto
alpha = (P2 / P1) ** (1 / (t2 - t1)) - 1

# Intervalo de tempo para prever o futuro
t_future = np.linspace(0, 60, 600)

# Cálculo da população futura usando o modelo discreto de Malthus
P_future = malthus_discrete_model(P0, t_future, alpha)

# Plotar o gráfico da população ao longo do tempo
plt.figure(figsize=(10, 6))
plt.plot(t_future, P_future, color='purple', label="Modelo Discreto de Malthus")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo Discreto de Malthus")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando a fórmula discreta de Malthus
def malthus_discrete_model(P0, t, alpha):
    Pt = P0 * np.exp(np.log(1 + alpha) * t)
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha para o modelo de Malthus discreto
alpha = (P2 / P1) ** (1 / (t2 - t1)) - 1

# Anos específicos para prever a população
specific_years = np.array([0, 10, 20, 30, 40, 50, 60])

# Cálculo da população futura nos anos específicos usando o modelo discreto de Malthus
P_specific = malthus_discrete_model(P0, specific_years, alpha)

# Plotar os resultados
plt.figure(figsize=(10, 6))
plt.plot(specific_years, P_specific, 'o-', color='purple', label="Previsão de P(t) - Modelo Discreto de Malthus")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo Discreto de Malthus - Valores Específicos")
plt.legend()
plt.grid(True)
plt.show()

# Exibir os valores calculados
for year, pop in zip(specific_years, P_specific):
    print(f"Ano: {year}, População prevista: {pop:.2f}")

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular P(t) usando o modelo discreto de Malthus
def malthus_discrete(P0, alpha, t):
    Pt = P0 * (1 + alpha) ** t
    return Pt

# Dados históricos
population_data = {
    0: 6661,    # População no ano 1970
    10: 4005,   # População no ano 1980
    20: 3151,   # População no ano 1990
    30: 2723,   # População no ano 2000
    40: 2727,   # População no ano 2010
    50: 2814    # População no ano 2022
}

# Parâmetros do modelo
P0 = population_data[0]  # População inicial

# Ajuste de alpha usando dados históricos iniciais (usando os primeiros dois pontos de dados)
t1 = 0
t2 = 10
P1 = population_data[t1]
P2 = population_data[t2]

# Cálculo de alpha para o modelo de Malthus discreto
alpha = (P2 / P1) ** (1 / (t2 - t1)) - 1

# Anos específicos para prever a população
specific_years = np.array([0, 10, 20, 30, 40, 50])

# Cálculo da população futura nos anos específicos usando o modelo discreto de Malthus
P_specific = malthus_discrete(P0, alpha, specific_years)

# Plotar os resultados
plt.figure(figsize=(10, 6))
plt.plot(specific_years, P_specific, 'o-', color='purple', label="Previsão de P(t) - Modelo Discreto de Malthus")
plt.scatter(list(population_data.keys()), list(population_data.values()), color='pink', s=100, label="Dados Históricos")
plt.xlabel("Tempo (anos)")
plt.ylabel("População (P(t))")
plt.title("Modelo Discreto de Malthus - Valores Específicos")
plt.legend()
plt.grid(True)
plt.show()

# Exibir os valores calculados
for year, pop in zip(specific_years, P_specific):
    print(f"Ano: {year}, População prevista: {pop:.2f}")